package ch54;

/*

자신이 상속받은 부모의 생성자를 호출하는 메소드 super()
자식클래스가 인스턴스를 생성하면, 인스턴스 안에는 자식 클래스의 고유 멤버 뿐만 아니라 부모 클래스의 모든 멤버까지 포함되어있다.

하지만 상속에서의 생성자는 상속되지 않는 유일한 멤버함수이다. 따라서 부모클래스의 멤버를 초기화하기 위해선, 당연히 부모클래스의 생성자를 호출해야할 것이다.
즉, 자식클래스 생성자를 호출할 때 부모클래스 생성자도 동시에 호출해야함. (정확히 말하면 부모 생성자가 먼저 실행됨)

그렇다면 자식 클래스 생성자 호출 할 때 super()를 같이 쓰면 되는구나! 라고 생각하게 됨. 하지만 이는 자바 컴파일러가 자동으로 super() 메소드를 추가해줌

그럼 여기서 의문점이 생길 것이다. 컴파일러가 알아서 부모 생성자를 호출해주는 메소드 super()를 추가해주는데(자동호출이니까 생략이 가능),
그럼 super() 메소드를 언제 쓰는 걸까?

컴파일러가 항상 super()를 자동 추가해주는 것은 아니다.
아래 예제처럼 부모클래스에 기본 생성자가 아닌 매개변수를 가지는 생성자가 있다면(=부모클래스에서 생성자가 오버로딩되면) 자동으로 추가되지 않음(=묵시적 제공을 하지 않음)

class Parent{
    int a;
    Parent(int n){a=n;};
}
아! 그럼 이 때 자식클래스 생성자 호출할 때 super()를 활용하면 되겠구나!

 class Parent{
     int a;
     Parent(int n){a=n;};
 }

 class Child extends Parent(){
     int b;
     Child(){
         super()
         b=20;
     }
 }
 // 이게 오류라면 super(20) 했을 땐 어떻게 될까? 나중에 되는지 test해보자
 // 기본생성자도 없고 매개변수가 있는 생성자도 없으면? 나중에 되는지 test
❌ 놉. 위의 코드는 오류가 발생함
왜냐하면 부모클래스 자체에 기본 생성자가 추가되지 않았기 때문임. 기본생성자를 호출할 때 부모클래스의 생성자에 기본생성자가 없으면 에러가 남.

어떻게 해야할까? 일단 2가지 방법이 있다.

1. 부모클래스에 기본 생성자 선언 (명시된 문제 그대로의 해결)

class Parent{
    int a;
    Parent(){a=10;};
    Parent(int n){a=n;};
}

class Child extends Parent(){
    int b;
    Child(){
        super();
        b=20;
    }
}
2. 오버로딩된 생성자에 맞춰 super()의 인자를 맞춰줌 (합리적 해결👍🏻)

class Parent{
    int a;
    Parent(int n){a=n;};
}

class Child extends Parent(){
    int b;
    Child(){
        super(40);
        b=20;
    }
}

출처:
https://velog.io/@rhdmstj17/java.-super%EC%99%80-super-%EC%99%84%EB%B2%BD%ED%95%98%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0

 */